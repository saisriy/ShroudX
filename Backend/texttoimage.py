# -*- coding: utf-8 -*-
"""texttoimagestego.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gpbHQ4C-uqebxCCsmn1BUfeCLF4xcmtV
"""



from PIL import Image
import matplotlib.pyplot as plt
#from google.colab import files
import os
from Crypto.Cipher import AES
import base64
import secrets

def Read_image(image_path) :
    image = Image.open(image_path)
    image = image.convert("RGB")
    pixels = image.load()
    return image,pixels

def Show_image(image) :
    plt.imshow(image)
    plt.axis("off")
    plt.show()

def get_image_size(image_path):
    with Image.open(image_path) as img:
        width, height = img.size
    return width, height

def generate_key():
    """Generates a secure 32-byte key and returns it as a base64 string."""
    return base64.b64encode(secrets.token_bytes(32)).decode()

#  PKCS7 Padding
def pad_message(message):
    """Pads the message to be a multiple of 16 bytes using PKCS7 padding."""
    message_bytes = message.encode()  # Convert string to bytes
    padding_length = 16 - (len(message_bytes) % 16)
    return message_bytes + bytes([padding_length] * padding_length)

#  PKCS7 Unpadding
def unpad_message(padded_message):
    """Removes PKCS7 padding after decryption."""
    padding_length = padded_message[-1]  # Get last byte
    if padding_length < 1 or padding_length > 16:
        raise ValueError("Invalid padding detected!")
    return padded_message[:-padding_length]  # Remove padding

#  Encrypt Message using AES-CBC
def encrypt_message(message, key):
    key = base64.b64decode(key)
    if len(key) != 32:
        raise ValueError("Invalid key length. AES-256 requires a 32-byte key.")

    # Generate a random 16-byte IV
    iv = os.urandom(16)

    # Create AES cipher in CBC mode
    cipher = AES.new(key, AES.MODE_CBC, iv)

    # Apply PKCS7 padding
    padded_message = pad_message(message)

    # Encrypt the message
    encrypted = cipher.encrypt(padded_message)

    # Return IV + encrypted message in Base64 format
    return base64.b64encode(iv + encrypted).decode()

#  Decrypt Message using AES-CBC
def decrypt_message(encrypted_message, key):
    key = base64.b64decode(key)  # Convert Base64 back to bytes
    encrypted_data = base64.b64decode(encrypted_message)

    #print("Decoded Key Length:", len(key))  # Should be 32 bytes
    #print("Encrypted Data Length:", len(encrypted_data))  # Should be > 16 bytes
    #print("Raw Encrypted Data:", encrypted_data[:64])  # Print first few bytes
    iv, encrypted_text = encrypted_data[:16], encrypted_data[16:]
    cipher = AES.new(key, AES.MODE_CBC, iv)
    decrypted = cipher.decrypt(encrypted_text)
    #print("Decrypted Message (Before Unpadding):", decrypted)
    final_message= unpad_message(decrypted).decode()
    #print(f"final message: {final_message}")
    return final_message

# key = generate_key()  #  Generate Key (Base64 format)
# message = "Hello, AES-CBC!"

# encrypted_msg = encrypt_message(message, key)  #  Encrypt
# decrypted_msg = decrypt_message(encrypted_msg, key)  #  Decrypt

# assert decrypted_msg == message, " Decryption Failed!"
# print(" Success! Decrypted Message:", decrypted_msg)

def encode_message(image_path, message):
    image,pixels = Read_image(image_path)
    """Encodes an AES-encrypted message inside an image using LSB steganography."""

    # Generate a random key
    secret_key = generate_key()
    #print("Generated Secret Key:", secret_key)  # Key must be saved to decode

    # Encrypt the message using the generated key
    encrypted_message = encrypt_message(message, secret_key)
    #print(f"Encrypted message :{encrypted_message}")
    #print(f"secret key {secret_key}")
    # Convert message to binary and add delimiter
    binary_message = ''.join(format(ord(char), '08b') for char in encrypted_message)
    binary_message += '1111111111111110'  # Special delimiter to mark end

    width, height = image.size
    index = 0

    for y in range(height):
        for x in range(width):
            if index < len(binary_message):
                r, g, b = pixels[x, y]
                # Modify the least significant bit (LSB) of the red channel
                r = (r & ~1) | int(binary_message[index])
                pixels[x, y] = (r, g, b)
                index += 1

    return image,secret_key

def start_encode(image_path,message_or_file,output_path) :
  if os.path.isfile(message_or_file):
        try:
            with open(message_or_file, "r", encoding="utf-8") as file:
                message = file.read().strip()
        except FileNotFoundError:
            print(f"Error: File '{message_or_file}' not found.")
            return None
  else:
        message = message_or_file
  width, height = get_image_size(image_path)
  print(f"width {width} height {height}")
  char_can_be_stored= ((width*height)//8) - 16
  chars= len(message)
  print(f"chars_can_be_stored {char_can_be_stored}")
  print(f"chars_entered {chars}")
  if chars> char_can_be_stored:
   print("entire message cant be stored")
   return None
  encoded_image,secret_key = encode_message(image_path, message)
  response= 'y'
  if response=='y' :
    # Save in PNG format to prevent compression artifacts
    encoded_image.save(output_path, "PNG")
    print(f"Stego image saved as {output_path}")
     
    # Download the image using Colab
  
  else :
   print("Image not saved")
  return encoded_image,secret_key

image_path = "256_butter.jpg"
  # Replace with your actual image path
message= "randomtext.txt"
output_path= "butter_new.png"
encoded_image,abc=start_encode(image_path, message, output_path)
if not encoded_image:
  print("Error: Encoding failed.")
else:
 Show_image(encoded_image)

def start_decode(image_path, secret_key):
    if isinstance(image_path, str):
        encoded_image = Image.open(image_path).convert("RGB")
    elif isinstance(image_path, Image.Image):
        encoded_image = image_path.convert("RGB")
    else:
        raise ValueError("Invalid input: Provide either an image file path or a PIL Image object")

    #encoded_image = Image.open(image_path).convert("RGB")
    pixels = encoded_image.load()
    width, height = encoded_image.size

    binary_message = ""

    for y in range(height):
        for x in range(width):
            r, _, _ = pixels[x, y]
            binary_message += str(r & 1)

    # Stop at delimiter and ensure it's a valid Base64 string length
    delimiter_index = binary_message.find("1111111111111110")
    if delimiter_index != -1:
        binary_message = binary_message[:delimiter_index]
        # Pad with zeros if necessary to make the length a multiple of 8 (for byte conversion)
        binary_message += '0' * (8 - (len(binary_message) % 8))  # Padding
    else:
        print("Warning: Delimiter not found. The message might be incomplete.")

    chars = [binary_message[i:i+8] for i in range(0, len(binary_message), 8)]
    message = ''.join(chr(int(char, 2)) for char in chars)
    # Check if message is valid Base64 before decoding
    # Add padding if required and try decoding

    try:
        message = message.rstrip('\x00')  # remove zero padding
        #print(f"message:{message}")
        #print(f"message in bytes:{base64.b64decode(message)}")
        decrypted_message = decrypt_message(message, secret_key)
        output_file = "decoded_message.txt"
        with open(output_file, "w", encoding="utf-8") as f:
         f.write(decrypted_message)

        print(f"Decrypted message saved to {output_file}")

        return decrypted_message

    except (base64.binascii.Error, ValueError) as e:
        print(f"Error decoding message: {e}")
        return None  
       

# Use the downloaded stego image for decoding
#image_to_decode= encoded_image
#print(abc)
decoded_message = start_decode(encoded_image,abc)
print("Decoded Message:", decoded_message)


